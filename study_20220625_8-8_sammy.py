"""
챕터 08 다이나믹 프로그래밍
효율적인 화폐 구성
N가지 종류의 화페
화폐들의 개수(N)를 최소한으로 이용하여 그 가치의 합이 M원이 되도록 만들기
화폐는 몇개라도 사용할 수 있으며 사용한 화폐의 구성은 같지만 순서만 다른 것은 같은 경우로 구분
첫째 줄에 N, M이 주어진다.
이후 N개의 줄에는 각 화폐의 가치가 주어진다. 화폐 가치는 10,000보다 작거나 같은 자연수이다.
첫째 줄에 M원을 만들기 위한 최소한의 화폐 개수를 출력한다.
불가능할 때는 -1을 출력한다.

힌트: 적은 금액부터 큰 금액까지 확인하며 차례대로 만들 수 있는 최소한의 화폐 개수를 찾으면 된다.

ex: 0원의 경우 화폐를 하나도 사용하지 않았을 경우도 존재. 따라서 초기 리스트의 값은 0으로 설정
"""

#정수 N,M을 입력받기
n, m = map(int, input().split())
#N개의 화폐 단위 정보를 입력받기
array = []
for i in range(n):
    array.append(int(input()))

#한 번 계산된 결과를 저장하기 위한 DP테이블 초기화
d = [10001] * (m+1)

#다이나믹 프로그래밍 진행(bottom-up)
d[0] = 0
for i in range(n):
    for j in range(array[i], m+1):
        if d[j - array[i]] != 10001: # (i-k)원을 만드는 방법이 존재하는 경우
            d[j] = min(d[j], d[j-array[i]] +1 )

#계산된 결과 출력
if d[m] == 10001: #최종적으로 M원을 만든느 방법이 없는 경우
    print(-1)
else:
    print(d[m])