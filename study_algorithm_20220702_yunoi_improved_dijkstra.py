# 챕터 9 최단 경로 (계속)
# 개선된 다익스트라 알고리즘
# 수행 시간을 줄인 알고리즘
# 힙 자료구조를 이용하여 특정 노드까지의 최단 거리 정보를 힙에 담아서 처리.
# 선형 시간이 아닌 로그 시간 소요하여 속도 개선.

# 힙 자료구조
# 우선순위 큐를 구현하기 위하여 사용하는 자료구조 중 하나.
# 우선순위 큐: 우선순위가 가장 높은 데이터를 가장 먼저 삭제
# 참고
# 자료구조    | 추출되는 데이터
# 스택        | 가장 나중에 삽입된 데이터
# 큐          | 가장 먼저 삽입된 데이터
# 우선순위 큐 | 가장 우선순위가 높은 데이터
# 데이터를 우선순위에 따라 처리하고 싶을 때 우선순위 큐 사용.
# ex. 여러 개의 물건 데이터를 자료구조에 넣었다가 가치가 높은 물건 데이터부터 꺼내서 확인해야 하는 경우 등.
# 파이썬에서는 우선순위 큐가 필요할 때 PriorityQueue 혹은 heapq 사용 가능.
# heapq가 일반적으로 더 빠르게 동작하기 때문에 권장.
# 우선순위 값을 표현할 때 일반적으로 정수형 자료형의 변수 사용.
# 파이썬 포함 대부분의 프로그래밍 언어에서는 우선순위 큐 라이브러리에 데이터 묶음을 넣으면 첫 번째 원소를 기준으로 우선순위 설정.
# 즉 데이터가 (가치, 물건)으로 구성된다면 '가치'가 우선순위 값이 되는 것.
# 우선순위 큐 구현 시 내부적으로 최소 힙 혹은 최대 힙 이용.
# 최소 힙: 값이 낮은 데이터가 먼저 삭제
# 최대 힙: 값이 큰 데이터가 먼저 삭제
# 파이썬 라이브러리는 기본적으로 최소 힙 구조 이용
# 팁
# 최소 힙을 최대 힙처럼 사용하기 위해서 일부러 우선순위에 해당하는 값에 음수 부호를 붙여 넣었다가, 
# 나중에 우선순위 큐에서 꺼낸 다음 다시 음수 부호를 붙여 원래의 값으로 돌리는 방식을 사용하기도 함.
# 우선순위 큐 구현 방법
# 리스트를 이용해서 구현 가능 (최단거리 테이블 등)
# 현재 가장 가까운 노드를 저장하기 위한 목적으로 우선순위 큐를 추가로 이용

import heapq
import sys
input = sys.stdin.readline
INF = int(1e9)

# 노드 개수, 간선 개수 입력
n,m = map(int, input().split())
# 시작 노드 번호 입력
start = int(input())
# 노드 정보 리스트
graph = [[] for i in range(n+1)]
# 최단 거리 테이블 무한으로 초기화
distance = [INF] * (n+1)

# 모든 간선 정보 입력
for _ in range(m):
  a,b,c = map(int, input().split())
  # a번 노드에서 b번 노드로 가는 비용이 c
  graph[a].append((b,c))
  
def dijkstra(start):
  q = []
  # 시작 노드로 가기 위한 최단 경로는 0으로 설정하여 큐에 삽입
  heapq.heappush(q, (0, start))
  distance[start] = 0
  while q: # 큐가 비어있지 않다면
    # 가장 최단 거리가 짧은 노드에 대한 정보 꺼내기
    dist, now = heapq.heappop(q)
    # 현재 노드가 이미 처리된 적 있는 노드라면 무시
    if distance[now] < dist:
      continue
    # 현재 노드와 연결된 다른 인접한 노드들 확인
    for i in graph[now]:
      cost = dist + i[1]
      # 현재 노드를 거쳐서 다른 노드로 이동하는 거리가 더 짧은 경우
      if cost < distance[i[0]]:
        distance[i[0]] = cost
        heapq.heappush(q, (cost, i[0]))

# 다익스트라 알고리즘 콜
dijkstra(start)

# 모든 노드로 가기 위한 최단 거리 출력
for i in range(1, n+1):
  if distance[i] == INF:
    print('INFINITY')
  else:
    print(distance[i])

