# 챕터  8 다이내믹 프로그래밍
# 탑다운, 보텀업, 메모이제이션..?
# ex 피보나치 수열
# 점화식: 인접한 항들 사이의 관계식

# 피보나치 함수 소스코드 
def fibo(x): 
    if x == 1 or x == 2:
        return 1
    return fibo(x-1) + fibo(x-2)

print('피보나치 함수 예제 1: ',fibo(4))

# 다이나믹 프로그래밍 조건
# 1. 큰 문제를 작은 문제로 나눌 수 있다.
# 2. 작은 문제에서 구한 정답은 그것을 포함하는 큰문제에서도 동일하다.

# 메모이제이션
# 다이나믹 프로그래밍을 구현하는 방법 중 한 종류. 
# 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법.
# 캐싱이라고도 한다.
# 한 번 구한 정보를 리스트에 저장하고, 다이나믹 프로그래밍을 재귀적으로 수행하다가 같은 정보가 필요할 때 이미 구한 정답을 리스트에서 가져오는 식으로 구현.

# 메모이제이션하기 위한 리스트 초기화
d = [0] * 100

# 피보나치 함수를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
def fibo2(x):
    # 종료 조건 (1 또는 2일 때 1을 반환)
    if x == 1 or x == 2:
        return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] != 0:
        return d[x]
    # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    d[x] = fibo2(x-1) + fibo2(x-2)
    return d[x]

print('피보나치 함수 예제 2: ',fibo2(99))

# 탑다운: 큰 문제를 해결하기 위해 작은 문제를 호출하는 방식.
# 보텀업: 작은 문제부터 차근차근 답을 도출하는 방식.

# 보텀업 방식 피보나치 수열 소스코드
e = [0] * 100
# 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
e[1] = 1
e[2] = 1
n = 99

# 피보나치 함수를 반복문으로 구현
for i in range(3, n+1):
    e[i] = e[i-1] + e[i-2]

print('보텀업 방식 피보나치 함수 결과: ', e[n])

# 탑다운(메모이제이션) 방식은 하향식이라고도 하며, 보텀업 방식은 상향식이라고도 한다. 
# 다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식이다.
# 보텀업 방식에서 사용되는 결과 저장용 리스트는 DP 테이블이라고 부르며, 메모이제이션은 탑다운 방식에 국한되어 사용되는 표현이다.
# 연속적이지 않은 경우 사전 자료형에 저장하는 것이 효과적.

def practice1(x):
    # 1. x가 5로 나누어떨어지면, 5로 나눈다.
    # 2. x가 3으로 나누어떨어지면, 3으로 나눈다.
    # 3. x가 2로 나누어떨어지면, 2로 나눈다.
    # 4. x에서 1을 뺀다.
    for i in range(2, x + 1):
        # 현재의 수에서 1을 빼는 경우
        f[i] = f[i-1] +1
        # 현재의 수가 2로 나누어 떨어지는 경우
        if i%2 == 0:
            f[i] = min(f[i], f[i//2] + 1)
        # 현재의 수가 3으로 나누어 떨어지는 경우
        if i%3 == 0:
            f[i] = min(f[i], f[i//3] + 1)
        # 현재의 수가 5로 나누어 떨어지는 경우
        if i%5 == 0:
            f[i] = min(f[i], f[i//5] + 1)
    # 위 연산 4개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력.
    print('answer: ', f[x])

f = [0] * 30001
print('input next')
#practice1(int(input()))

def practice2(x):
    # 모든 식량 정보 입력받기
    array = list(map(int, input().split()))

    g[0] = array[0]
    g[1] = max(array[0], array[1])
    for i in range(2, x):
        g[i] = max(g[i-1], g[i-2] + array[i])
    
    print('answer 2: ', g[x-1])

g = [0] * 100
#practice2(int(input()))

def practice3(x):
    h[1] = 1
    h[2] = 3

    for i in range(3, x+1):
        h[i] = (h[i-1] + 2 * h[i-2]) % 796796
    
    print('answer 3: ', h[x])

h = [0] * 1001
#practice3(int(input()))

def practice4():
    # n가지 종류 화폐, 가치의 합이 m
    n,m = map(int, input().split())
    # n개의 회폐 단위 정보 입력
    array = []
    for i in range(n):
        array.append(int(input()))
    # dp table 초기화
    k = [10001] * (m+1)

    # 바텀업
    k[0] = 0
    for i in range(n):
        for j in range(array[i], m+1):
            if k[j-array[i]] != 10001: # i-k 원을 만드는 방법이 존재하는 경우
                k[j] = min(k[j], k[j - array[i]]+1)

    if k[m] == 10001: # 최종적으로 m원을 만드는 방법이 없는 경우
        print('answer 4: ', -1)
    else:
        print('answer 4: ', k[m])

# n가지 종류의 화폐
# 이 화페들의 개수를 최소한으로 이용해서 그 가치의 합이 m원이 되도록
# 첫째 줄에 n, m 입력
# 이후 n개의 줄에는 각 화폐의 가치 입력. 화페 가치는 10,000보다 작거나 같은 자연수.

# 화폐 단위 k 크기만큼 리스트 할당. 각 인덱스를 '금액'으로 고려하여 메모이제이션 진행.
# ex. n = 3, k = 7이고, 각 화폐 단위가 2, 3, 5 일 때
# 1. 초기화: 각 인덱스에 해당하는 값으로 10,001을 설정. 10,001은 특정 금액을 만들 수 있는 화폐 구성이 불가능하다는 의미.
# (m의 최대 크기가 10,000이라서 편의상 10,001로 설정함)
# 인덱스  0 (0원)은 화폐를 사용하지 않으므로 0으로 설정
# k = [10001] * 7
# k[0] = 0
# 2. 화폐 단위별 확인
# 2부터 확인
# k[2] = 1, k[4] = 2, k[6] = 3
# 3일 때
# k[3] = 1, k[5] = 2 (2단위 1개 + 3단위 1개로 구성 가능), k[6] = 2, k[7] = 3
# 5 확인
# k[5] = 1, k[7] = 2
practice4()